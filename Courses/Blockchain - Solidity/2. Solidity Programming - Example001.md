# Solidity Programming
## The Basic Structure
```
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.18 <0.9;

contract SimpleStorage{
    
}
```

The code snippet from the class note  introduces a basic structure for a Solidity smart contract named `SimpleStorage`. Here's a breakdown of its components for easy reference:

- **SPDX-License-Identifier**: `// SPDX-License-Identifier: MIT`
    - This comment specifies the license under which the smart contract is released. The MIT license is chosen here, indicating that the software is free to use, modify, and distribute, provided that all copies include a copy of the license itself. It's a common practice to include such a license identifier to make the licensing clear and straightforward.

- **Pragma Directive**: `pragma solidity >=0.8.18 <0.9;`
    - This line defines the compiler version to be used for compiling the contract. It ensures that the contract will only be compiled with a compiler version greater than or equal to `0.8.18` and less than `0.9.0`. This is crucial for avoiding issues related to compiler version incompatibility, ensuring that the contract takes advantage of the latest language features while avoiding breaking changes in future versions.

- **Contract Declaration**: `contract SimpleStorage{ }`
    - This part of the code defines a new contract named `SimpleStorage`. In Solidity, a contract is a collection of code (its functions) and data (its state) that resides at a specific address on the Ethereum blockchain. The name `SimpleStorage` suggests that the contract's purpose might be related to storing some form of data, although the internal details and functionalities are not provided within this snippet.

This snippet serves as a foundational template for developing a smart contract in Solidity. It includes essential components such as licensing information, compiler version specification, and the contract's basic structure, setting the stage for further development and implementation of the contract's functionalities.

## Types
```
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.18 <0.9;

contract SimpleStorage{
    // Basic Types: boolean, uint, int, address, bytes

    bool hasFavoriteNumber = false;
    int256 favoriteIntNumber = -99;
    string favoriteNumberInText = '99';
    uint favoriteUintNumber = 44;

    address myAddress = 0xAD547FdbeD1794A66270ec20D47138270c4bF5ee;
    bytes32 favoriteBytes32 = 'cat';

}
```

The code snippet from the file expands the `SimpleStorage` contract to include examples of basic data types in Solidity. Here's a detailed explanation of each component within this expanded section:

## Basic Types in Solidity

Solidity supports various data types, and this snippet demonstrates some of the basic ones:

- **Boolean**: `bool hasFavoriteNumber = false;`
    - A boolean variable named `hasFavoriteNumber` is declared and initialized to `false`. Booleans represent binary values (`true` or `false`).

- **Integer**: `int256 favoriteIntNumber = -99;`
    - An integer variable `favoriteIntNumber` is declared with a type of `int256`, indicating a 256-bit signed integer. It's initialized with a value of `-99`. Solidity provides `int` types of various sizes, but `int256` is often used by default.

- **Unsigned Integer**: `uint favoriteUintNumber = 44;`
    - An unsigned integer variable `favoriteUintNumber` is declared with a type of `uint`, which is an alias for `uint256`, indicating a 256-bit unsigned integer. It's initialized with `44`. Unlike `int`, `uint` types cannot represent negative values.

- **String**: `string favoriteNumberInText = '99';`
    - A string variable `favoriteNumberInText` is declared and initialized with the value `'99'`. Strings in Solidity are used to represent textual data.

- **Address**: `address myAddress = 0xAD547FdbeD1794A66270ec20D47138270c4bF5ee;`
    - An address variable `myAddress` is declared and initialized with a hexadecimal Ethereum address. Addresses are 20-byte values that represent an account on the Ethereum blockchain, which can be an externally owned account (EOA) or a contract.

- **Bytes32**: `bytes32 favoriteBytes32 = 'cat';`
    - A `bytes32` variable `favoriteBytes32` is declared and initialized with the value `'cat'`. The `bytes32` type is used for fixed-size byte sequences. This example demonstrates storing a short string in a `bytes32` type, but it's more commonly used for cryptographic hashes and other fixed-length data.

This section of the `SimpleStorage` contract serves as an illustrative example of how different basic data types can be declared and initialized in Solidity. Understanding these types is fundamental for developing more complex logic and functionalities in smart contracts.

## Functions

```
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.18 <0.9;

contract SimpleStorage{
    // Functions 

    uint256 public favoriteNumber; // default value 0

    function store(uint256 _favoriteNumber) public {
        favoriteNumber = _favoriteNumber;
    }

}
```
Continuing from the previous section of the `SimpleStorage` contract in the file, we delve into the concept of functions and visibility specifiers in Solidity. This part introduces a simple function within the `SimpleStorage` contract.

### Functions in Solidity

Functions are the primary way of executing logic and manipulating data within a contract. The `SimpleStorage` contract includes a function named `store`:

- **Function `store`**: 
    - `function store(uint256 _favoriteNumber) public {`
    - This function takes one parameter, `_favoriteNumber`, of type `uint256` and is marked with the `public` visibility specifier. It assigns the value of `_favoriteNumber` to the state variable `favoriteNumber`.
    - The `public` specifier means this function can be called both internally, by other functions in this contract or derived contracts, and externally, via transactions or calls.

### Visibility Specifiers

Solidity provides several visibility specifiers for functions and variables to control where they can be accessed from:

- **Public**: 
    - Variables and functions marked as `public` are accessible from anywhere. For variables, Solidity automatically creates a getter function.
    - Example: `uint256 public favoriteNumber;` makes `favoriteNumber` accessible and modifiable through the `store` function.

- **Private**:
    - Private functions and variables are only accessible within the contract they are defined in, not in derived contracts.
    - Example: `uint256 private secretNumber;` would make `secretNumber` accessible only within methods of the same contract.

- **Internal**:
    - Similar to `private`, but also accessible in contracts that inherit from the one where the `internal` member is defined.
    - Example: `uint256 internal internalNumber;` allows access from the defining contract and its derived contracts.

- **External**:
    - External functions can only be called from outside the contract and not from other functions within the contract. This can be more gas-efficient when a function is called externally.
    - Example: `function externalStore(uint256 _number) external;` can only be called from outside the contract.

The `SimpleStorage` contract's use of the `public` specifier for both the `favoriteNumber` variable and the `store` function demonstrates a basic pattern for allowing external interaction with a contract's state in a controlled manner. Understanding the differences between these visibility specifiers is crucial for smart contract development, as it affects both the functionality and security of the contract.